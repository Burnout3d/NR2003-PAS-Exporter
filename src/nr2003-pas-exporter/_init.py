## ***** BEGIN GPL LICENSE BLOCK ***** 
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either version 2 
# of the License, or (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software Foundation, 
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
# 
# ***** END GPL LICENCE BLOCK *****
bl_info = {
    "name": "Papyrus ASCII Scene Exporter",
    "author": "Burnout3D",
    "blender": (4, 0, 0),
    "doc_url": "https://github.com/Burnout3d/NR2003-PAS-Exporter",
    "category": "Import-Export",
}
import os
import bpy
import bmesh
import mathutils
from bpy_extras.io_utils import ExportHelper
from bpy.props import StringProperty, EnumProperty
from bpy.types import Operator

class ExportPapyrus(Operator, ExportHelper):
    bl_idname = "export_scene.pas"
    bl_label = "Export Papyrus ASCII Format"
    
    filename_ext = ".pas"
    
    filter_glob: StringProperty(
        default="*.pas",
        options={'HIDDEN'},
        maxlen=255,
    )
    
    export_type: EnumProperty(
        name="Export Type",
        description="Choose what to export",
        items=(
            ('ALL', "All Objects", "Export all objects in the scene"),
            ('SELECTED', "Selected Objects", "Export selected objects"),
            ('VISIBLE', "Visible Objects", "Export visible objects"),
        ),
        default='ALL',
    )
    
    def get_unit_conversion_factor(self):
        scene = bpy.context.scene
        unit_settings = scene.unit_settings
        unit_scale = unit_settings.scale_length
        
        # Conversion factors for different unit systems
        if unit_settings.system == 'METRIC':
            if unit_settings.length_unit == 'KILOMETERS':
                return unit_scale * 1000.0
            elif unit_settings.length_unit == 'METERS':
                return unit_scale
            elif unit_settings.length_unit == 'CENTIMETERS':
                return unit_scale * 0.01
            elif unit_settings.length_unit == 'MILLIMETERS':
                return unit_scale * 0.001
            elif unit_settings.length_unit == 'MICROMETERS':
                return unit_scale * 1e-6
        elif unit_settings.system == 'IMPERIAL':
            if unit_settings.length_unit == 'MILES':
                return unit_scale * 1609.34
            elif unit_settings.length_unit == 'FEET':
                return unit_scale * 0.3048
            elif unit_settings.length_unit == 'INCHES':
                return unit_scale * 0.0254
            elif unit_settings.length_unit == 'THOU':
                return unit_scale * 0.0000254
        else:
            # Default to 1.0 if no unit system is set
            return 1.0
    
    def topological_sort_objects(self, objects):
        sorted_objects = []
        visited = set()

        def visit(obj):
            if obj not in visited:
                visited.add(obj)
                if obj.parent:
                    visit(obj.parent)
                sorted_objects.append(obj)

        for obj in objects:
            visit(obj)

        return sorted_objects

    def execute(self, context):
        filepath = self.filepath
        export_type = self.export_type
        
        objects = []
        if export_type == 'ALL':
            objects = context.scene.objects
        elif export_type == 'SELECTED':
            objects = context.selected_objects
        elif export_type == 'VISIBLE':
            objects = [obj for obj in context.scene.objects if obj.visible_get()]
        
        unit_conversion_factor = self.get_unit_conversion_factor()
        
        # Get the current Blender file name
        blend_file_name = bpy.path.basename(bpy.data.filepath)
        
        # Sort objects topologically based on parent-child relationships
        sorted_objects = self.topological_sort_objects(objects)
        
        with open(filepath, 'w') as file:
            file.write("#############################################\n#\n# DO NOT EDIT THIS FILE!!!!!\n#\n# This Papyrus Ascii Scene file was GENERATED\n# by exporting as a PAS file from BLENDER\n#\n")
            file.write(f"# Source file = '{blend_file_name}'\n")
            file.write("#\n# Blender Exporter by Burnout3D.\n#\n#############################################\n")
            file.write("VERSION\t200\n")
            file.write(f"UNIT_CONVERSION\t{unit_conversion_factor:.6f}\n")
            for obj in sorted_objects:
                if obj.type == 'MESH':  # Check only mesh objects
                    file.write("SHAPE {\n")
                    file.write('\tNAME "{}"\n'.format(obj.name))
                    
                    # Check if the object has a parent
                    if obj.parent:
                        file.write('\tPARENT "{}"\n'.format(obj.parent.name))
                    
                    file.write("\tTRANSFORM {\n")
                    for i in range(3):  # Only write the first three rows of the matrix
                        row = obj.matrix_world[i]
                        formatted_row = '\t'.join(f'{value:.5f}' for value in row[:3])
                        file.write('\t\tXFORM_ROW{} {}\n'.format(i, formatted_row))
                    # Write the fourth row (translation part) separately
                    row = obj.matrix_world.translation
                    formatted_row = '\t'.join(f'{value:.5f}' for value in row)
                    file.write('\t\tXFORM_ROW3 {}\n'.format(formatted_row))
                    # Write the location as XFORM_POS
                    formatted_location = '\t'.join(f'{value:.5f}' for value in obj.location)
                    file.write('\t\tXFORM_POS {}\n'.format(formatted_location))
                    file.write("\t}\n")

                    # Function to get keyframe values and ensure required samples
                    def get_keyframe_values(fcurves, required_samples, is_quaternion=False):
                        keyframe_values = {}
                        
                        for fcurve in fcurves:
                            for keyframe in fcurve.keyframe_points:
                                frame = int(keyframe.co[0]) * 160
                                if frame not in keyframe_values:
                                    keyframe_values[frame] = [0.0, 0.0, 0.0, 0.0] if is_quaternion else [0.0, 0.0, 0.0]
                                index = fcurve.array_index
                                keyframe_values[frame][index] = keyframe.co[1]
                        
                        # Ensure required samples are included and repeat last keyframe if necessary
                        sorted_frames = sorted(keyframe_values.keys())
                        last_value = keyframe_values[sorted_frames[-1]]
                        for sample in required_samples:
                            if sample not in keyframe_values:
                                keyframe_values[sample] = last_value
                            else:
                                last_value = keyframe_values[sample]
                        
                        return keyframe_values

                    # Function to convert Euler keyframes to Quaternion keyframes and reorder to WZYX
                    def convert_euler_to_quaternion(euler_keyframes):
                        quaternion_keyframes = {}
                        for frame, euler_angles in euler_keyframes.items():
                            euler = mathutils.Euler(euler_angles, 'XYZ')
                            quaternion = euler.to_quaternion()
                            # Reorder to ZXYW and invert values
                            quaternion_keyframes[frame] = [-quaternion.w, -quaternion.z, -quaternion.y, -quaternion.x]
                        return quaternion_keyframes

                    # Required samples
                    required_samples = [0, 800, 1600, 2400, 3200, 4000, 4800]

                    # Check if the object has animation data
                    if obj.animation_data and obj.animation_data.action:
                        action = obj.animation_data.action
                        pos_track = False
                        rot_track = False

                        # Check for position and rotation keyframes
                        pos_fcurves = []
                        rot_fcurves = []
                        euler_fcurves = {'rotation_euler': [[], [], []]}

                        for fcurve in action.fcurves:
                            if fcurve.data_path == "location":
                                pos_track = True
                                pos_fcurves.append(fcurve)
                            if fcurve.data_path == "rotation_quaternion":
                                rot_track = True
                                rot_fcurves.append(fcurve)
                            if fcurve.data_path.startswith("rotation_euler"):
                                rot_track = True
                                euler_fcurves['rotation_euler'][fcurve.array_index].append(fcurve)

                        if pos_track or rot_track:
                            file.write("\tXFORM_ANIMATION {\n")

                            if pos_track:
                                file.write("\t\tPOS_TRACK {\n")
                                keyframe_values = get_keyframe_values(pos_fcurves, required_samples)
                                for frame, value in sorted(keyframe_values.items()):
                                    file.write(f'\t\t\tPOS_SAMPLE {frame}\t{value[0]:.5f}\t{value[1]:.5f}\t{value[2]:.5f}\n')
                                file.write("\t\t}\n")

                            if rot_track:
                                if rot_fcurves:
                                    file.write("\t\tROT_TRACK {\n")
                                    keyframe_values = get_keyframe_values(rot_fcurves, required_samples, is_quaternion=True)
                                    for frame, value in sorted(keyframe_values.items()):
                                        # Reorder to ZXYW and invert values
                                        reordered_value = [-value[2], -value[0], -value[1], -value[3]]
                                        file.write(f'\t\t\tROT_SAMPLE {frame}\t{reordered_value[0]:.5f}\t{reordered_value[1]:.5f}\t{reordered_value[2]:.5f}\t{reordered_value[3]:.5f}\n')
                                    file.write("\t\t}\n")
                                elif any(euler_fcurves['rotation_euler']):
                                    file.write("\t\tROT_TRACK {\n")
                                    euler_keyframe_values = {}
                                    for i, fcurves in enumerate(euler_fcurves['rotation_euler']):
                                        if fcurves:
                                            keyframe_values = get_keyframe_values(fcurves, required_samples)
                                            for frame, value in keyframe_values.items():
                                                if frame not in euler_keyframe_values:
                                                    euler_keyframe_values[frame] = [0.0, 0.0, 0.0]
                                                euler_keyframe_values[frame][i] = value[0]
                                    quaternion_keyframe_values = convert_euler_to_quaternion(euler_keyframe_values)
                                    for frame, value in sorted(quaternion_keyframe_values.items()):
                                        file.write(f'\t\t\tROT_SAMPLE {frame}\t{value[0]:.5f}\t{value[1]:.5f}\t{value[2]:.5f}\t{value[3]:.5f}\n')
                                    file.write("\t\t}\n")

                            file.write("\t}\n")
                    
                    # Assuming obj is already defined and is the object you want to export
                    mesh = obj.data
                    
                    # Triangulate the mesh
                    bpy.ops.object.mode_set(mode='OBJECT')
                    bpy.context.view_layer.objects.active = obj
                    bpy.ops.object.mode_set(mode='EDIT')
                    bpy.ops.mesh.select_all(action='SELECT')
                    bpy.ops.mesh.quads_convert_to_tris()
                    bpy.ops.object.mode_set(mode='OBJECT')
                    
                    file.write("\tMESH {\n")
                    file.write("\t\tNUM_VERTICES {}\n".format(len(mesh.vertices)))
                    file.write("\t\tVERTEX_LIST {\n")
                    for i, v in enumerate(mesh.vertices):
                        file.write('\t\t\tVERTEX\t {}:\t{:.5f}\t{:.5f}\t{:.5f}\n'.format(i, v.co.x, v.co.y, v.co.z))
                    file.write("\t\t}\n")
                    
                    file.write("\t\tNUM_FACES {}\n".format(len(mesh.polygons)))
                    file.write("\t\tFACE_LIST {\n")
                    for i, p in enumerate(mesh.polygons):
                        verts = ' '.join(map(str, p.vertices))
                        file.write('\t\t\tFACE {}: \t{}\n'.format(i, verts))
                    file.write("\t\t}\n")
                    
                    file.write("\t\tNORMAL_LIST {\n")
                    mesh.calc_normals_split()
                    for i, p in enumerate(mesh.polygons):
                        normal = p.normal
                        file.write('\t\t\tFACE_NORMAL {}: 1 {:.5f}\t{:.5f}\t{:.5f}\n'.format(
                            i, normal.x, normal.y, normal.z))
                        for j, loop_index in enumerate(p.loop_indices):
                            normal = mesh.loops[loop_index].normal
                            vertex_index = mesh.loops[loop_index].vertex_index
                            file.write('\t\t\t\tVERTEX_NORMAL {}\t{:.5f}\t{:.5f}\t{:.5f}\n'.format(
                                vertex_index, normal.x, normal.y, normal.z))
                    file.write("\t\t}\n")
                    mesh.free_normals_split()
                    
                    if len(obj.material_slots) > 0:
                        file.write("\t\tNUM_MATERIAL_REFS 1\n")
                        file.write("\t\tMATERIAL_REF {\n")
                        mat = obj.material_slots[0].material
                        file.write('\t\t\tMATERIAL {\n')
                        file.write('\t\t\t\tNAME "{}"\n'.format(mat.name))
                        
                        if "NR2003-Material" in mat.node_tree.nodes:
                            node_group = mat.node_tree.nodes["NR2003-Material"]
                            
                        # Initialize a list to store texture paths and their titles
                        texture_paths = []

                        # List of attributes that should always be shown
                        always_show_attributes = ["MATERIAL_AMBIENT", "MATERIAL_DIFFUSE", "MATERIAL_SPECULAR", "MATERIAL_SHININESS", "MATERIAL_REFLECTIVITY", "MATERIAL_OPACITY"]

                        # Function to check if an image has an alpha channel
                        def has_alpha_channel(image):
                            return image.depth == 32

                        # Iterate through the inputs of the node group
                        for input in node_group.inputs:
                            if input.is_linked:
                                linked_node = input.links[0].from_node
                                if linked_node.type == 'TEX_IMAGE':
                                    relative_path = linked_node.image.filepath
                                    absolute_path = bpy.path.abspath(relative_path)
                                    normalized_path = os.path.normpath(absolute_path)
                                    if os.path.isabs(normalized_path):
                                        final_path = normalized_path
                                    else:
                                        final_path = os.path.join(bpy.path.abspath("//"), normalized_path)
                                    
                                    texture_paths.append((input.name, final_path))
                                    
                                    disable_alpha = "" if has_alpha_channel(linked_node.image) else "\tDISABLE_ALPHA"
                                    
                                    if input.name == "Base Texture":
                                        file.write(f'\t\t\t\tBASE_TEXTURE "{final_path}"{disable_alpha}\n')
                                    elif input.name == "Shininess Map Texture":
                                        file.write(f'\t\t\t\tSHININESS_MAP_TEXTURE "{final_path}"{disable_alpha}\n')
                                    elif input.name == "Environment Map Texture":
                                        file.write(f'\t\t\t\tENVIRONMENT_MAP_TEXTURE "{final_path}"{disable_alpha}\n')
                            else:
                                if hasattr(input, 'default_value'):
                                    if isinstance(input.default_value, (bpy.types.bpy_prop_array, list, tuple)) and len(input.default_value) == 4:
                                        formatted_value = ' '.join(f"{v:.5f}" for v in input.default_value[:3])
                                        if input.name.upper() in always_show_attributes:
                                            file.write(f'\t\t\t\t{input.name.upper()} {formatted_value}\n')
                                    elif isinstance(input.default_value, (bpy.types.bpy_prop_array, list, tuple)) and len(input.default_value) == 3:
                                        formatted_value = ' '.join(f"{v:.5f}" for v in input.default_value)
                                        if input.name.upper() in always_show_attributes:
                                            file.write(f'\t\t\t\t{input.name.upper()} {formatted_value}\n')
                                    else:
                                        if input.name.upper() in always_show_attributes:
                                            file.write(f"\t\t\t\t{input.name} {input.default_value:.5f}\n")
                                else:
                                    if input.name.upper() in always_show_attributes:
                                        file.write(f"\t\t\t\tInput '{input.name}' has no default value attribute.\n")

                        # file.write the texture paths and their titles
                        for title, path in texture_paths:
                            disable_alpha = "" if has_alpha_channel(bpy.data.images.load(path)) else "\tDISABLE_ALPHA"
                            file.write(f'\t\t\t\t{title.upper()} "{path}"{disable_alpha}\n')
                            
                            #file.write('\t\t\t}\n')
                            #file.write('\t\t}\n')
                        
                        file.write("\t\t\t}\n")
                        
                        # Function to flip UVs vertically
                        def flip_uvs_vertically(uv_coords):
                            return [(uv[0], 1.0 - uv[1]) for uv in uv_coords]

                        # Function to check if UV map is connected to the texture node
                        def is_uv_connected_to_texture(material):
                            if material.use_nodes:
                                for node in material.node_tree.nodes:
                                    if node.type == 'TEX_IMAGE':
                                        for input in node.inputs:
                                            if input.is_linked:
                                                for link in input.links:
                                                    if link.from_node.type == 'UVMAP':
                                                        return True
                            return False

                        # Assuming you have the object and material selected
                        uv_layer = mesh.uv_layers.active.data if mesh.uv_layers.active else None

                        # Write the number of faces
                        file.write("\t\t\tNUM_FACES {}\n".format(len(mesh.polygons)))

                        # Iterate through the polygons and apply the UV flip if not connected to texture
                        for i, p in enumerate(mesh.polygons):
                            if uv_layer:
                                uv_coords = [uv_layer[loop_index].uv for loop_index in p.loop_indices]
                                # Check if UV map is connected to the texture node
                                if not any(is_uv_connected_to_texture(mat) for mat in obj.data.materials):
                                    uv_coords = flip_uvs_vertically(uv_coords)
                                base_texture_coords = ' '.join(f'({uv[0]:.4f}, {uv[1]:.4f})' for uv in uv_coords)
                            else:
                                base_texture_coords = "(0.0, 0.0) (0.0, 0.0) (0.0, 0.0)"
                            
                            # Check for a separate UV layer for the shininess map
                            shininess_uv_layer = mesh.uv_layers.get("shininess_map")
                            if shininess_uv_layer:
                                shininess_uv_coords = [shininess_uv_layer.data[loop_index].uv for loop_index in p.loop_indices]
                                flipped_shininess_uv_coords = flip_uvs_vertically(shininess_uv_coords)
                                shininess_map_coords = ' '.join(f'({uv[0]:.4f}, {uv[1]:.4f})' for uv in flipped_shininess_uv_coords)
                            else:
                                shininess_map_coords = base_texture_coords  # Fallback to base texture coordinates if no separate UV layer
                            
                            file.write(f'\t\t\tTEXTURE_FACE {i} BASE_TEXTURE {base_texture_coords} SHININESS_MAP_TEXTURE {shininess_map_coords}\n')
                        file.write("\t\t}\n")
                    else:
                        file.write("\t\tNUM_MATERIAL_REFS 0\n")
                    file.write("\t}\n")
                    file.write("}\n")

        
        return {'FINISHED'}
    
    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

def menu_func_export(self, context):
    self.layout.operator(ExportPapyrus.bl_idname, text="Papyrus ASCII Scene (.pas)")

def register():
    bpy.utils.register_class(ExportPapyrus)
    bpy.types.TOPBAR_MT_file_export.append(menu_func_export)

def unregister():
    bpy.utils.unregister_class(ExportPapyrus)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func_export)

if __name__ == "__main__":
    register()
