## ***** BEGIN GPL LICENSE BLOCK ***** 
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either version 2 
# of the License, or (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software Foundation, 
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
# 
# ***** END GPL LICENCE BLOCK *****
bl_info = {
    "name": "Papyrus ASCII Scene Exporter",
    "author": "Burnout3D",
    "blender": (4, 0, 0),
    "doc_url": "https://github.com/Burnout3d/NR2003-PAS-Exporter",
    "category": "Import-Export",
}
import os
import bpy
import bmesh
from bpy_extras.io_utils import ExportHelper
from bpy.props import StringProperty, EnumProperty
from bpy.types import Operator

class ExportPapyrus(Operator, ExportHelper):
    bl_idname = "export_scene.pas"
    bl_label = "Export Papyrus ASCII Format"
    
    filename_ext = ".pas"
    
    filter_glob: StringProperty(
        default="*.pas",
        options={'HIDDEN'},
        maxlen=255,
    )
    
    export_type: EnumProperty(
        name="Export Type",
        description="Choose what to export",
        items=(
            ('ALL', "All Objects", "Export all objects in the scene"),
            ('SELECTED', "Selected Objects", "Export selected objects"),
            ('VISIBLE', "Visible Objects", "Export visible objects"),
        ),
        default='ALL',
    )
    
    def get_unit_conversion_factor(self):
        scene = bpy.context.scene
        unit_settings = scene.unit_settings
        unit_scale = unit_settings.scale_length
        
        # Conversion factors for different unit systems
        if unit_settings.system == 'METRIC':
            if unit_settings.length_unit == 'KILOMETERS':
                return unit_scale * 1000.0
            elif unit_settings.length_unit == 'METERS':
                return unit_scale
            elif unit_settings.length_unit == 'CENTIMETERS':
                return unit_scale * 0.01
            elif unit_settings.length_unit == 'MILLIMETERS':
                return unit_scale * 0.001
            elif unit_settings.length_unit == 'MICROMETERS':
                return unit_scale * 1e-6
        elif unit_settings.system == 'IMPERIAL':
            if unit_settings.length_unit == 'MILES':
                return unit_scale * 1609.34
            elif unit_settings.length_unit == 'FEET':
                return unit_scale * 0.3048
            elif unit_settings.length_unit == 'INCHES':
                return unit_scale * 0.0254
            elif unit_settings.length_unit == 'THOU':
                return unit_scale * 0.0000254
        else:
            # Default to 1.0 if no unit system is set
            return 1.0
    
    def execute(self, context):
        filepath = self.filepath
        export_type = self.export_type
        
        objects = []
        if export_type == 'ALL':
            objects = context.scene.objects
        elif export_type == 'SELECTED':
            objects = context.selected_objects
        elif export_type == 'VISIBLE':
            objects = [obj for obj in context.scene.objects if obj.visible_get()]
        
        unit_conversion_factor = self.get_unit_conversion_factor()
        
        # Get the current Blender file name
        blend_file_name = bpy.path.basename(bpy.data.filepath)
        
        with open(filepath, 'w') as file:
            file.write("#############################################\n#\n# DO NOT EDIT THIS FILE!!!!!\n#\n# This Papyrus Ascii Scene file was GENERATED\n# by exporting as a PAS file from BLENDER\n#\n")
            file.write(f"# Source file = '{blend_file_name}'\n")
            file.write("#\n# Blender Exporter by Burnout3D.\n#\n#############################################\n")
            file.write("VERSION\t200\n")
            file.write(f"UNIT_CONVERSION\t{unit_conversion_factor:.6f}\n")
            for obj in bpy.context.scene.objects:
                if obj.type == 'MESH':  # Check only mesh objects
                    file.write("SHAPE {\n")
                    file.write('\tNAME "{}"\n'.format(obj.name))
                    file.write("\tTRANSFORM {\n")
                    for i in range(3):  # Only write the first three rows of the matrix
                        row = obj.matrix_world[i]
                        formatted_row = '\t'.join(f'{value:.5f}' for value in row[:3])
                        file.write('\t\tXFORM_ROW{} {}\n'.format(i, formatted_row))
                    # Write the fourth row (translation part) separately
                    row = obj.matrix_world.translation
                    formatted_row = '\t'.join(f'{value:.5f}' for value in row)
                    file.write('\t\tXFORM_ROW3 {}\n'.format(formatted_row))
                    # Write the location as XFORM_POS
                    formatted_location = '\t'.join(f'{value:.5f}' for value in obj.location)
                    file.write('\t\tXFORM_POS {}\n'.format(formatted_location))
                    file.write("\t}\n")
                    
                    mesh = obj.data
                    file.write("\tMESH {\n")
                    file.write("\t\tNUM_VERTICES {}\n".format(len(mesh.vertices)))
                    file.write("\t\tVERTEX_LIST {\n")
                    for i, v in enumerate(mesh.vertices):
                        file.write('\t\t\tVERTEX\t {}:\t{:.5f}\t{:.5f}\t{:.5f}\n'.format(i, v.co.x, v.co.y, v.co.z))
                    file.write("\t\t}\n")
                    
                    file.write("\t\tNUM_FACES {}\n".format(len(mesh.polygons)))
                    file.write("\t\tFACE_LIST {\n")
                    for i, p in enumerate(mesh.polygons):
                        verts = ' '.join(map(str, p.vertices))
                        file.write('\t\t\tFACE {}: \t{}\n'.format(i, verts))
                    file.write("\t\t}\n")
                    
                    file.write("\t\tNORMAL_LIST {\n")
                    mesh.calc_normals_split()
                    for i, p in enumerate(mesh.polygons):
                        normal = p.normal
                        file.write('\t\t\tFACE_NORMAL {}: 1 {:.5f}\t{:.5f}\t{:.5f}\n'.format(
                            i, normal.x, normal.y, normal.z))
                        for j, loop_index in enumerate(p.loop_indices):
                            normal = mesh.loops[loop_index].normal
                            vertex_index = mesh.loops[loop_index].vertex_index
                            file.write('\t\t\t\tVERTEX_NORMAL {}\t{:.5f}\t{:.5f}\t{:.5f}\n'.format(
                                vertex_index, normal.x, normal.y, normal.z))
                    file.write("\t\t}\n")
                    mesh.free_normals_split()
                    
                    if len(obj.material_slots) > 0:
                        file.write("\t\tNUM_MATERIAL_REFS 1\n")
                        file.write("\t\tMATERIAL_REF {\n")
                        mat = obj.material_slots[0].material
                        file.write('\t\t\tMATERIAL {\n')
                        file.write('\t\t\t\tNAME "{}"\n'.format(mat.name))
                        
                        if "NR2003-Material" in mat.node_tree.nodes:
                            node_group = mat.node_tree.nodes["NR2003-Material"]
                            
                        # Initialize a list to store texture paths and their titles
                        texture_paths = []

                        # List of attributes that should always be shown
                        always_show_attributes = ["MATERIAL_AMBIENT", "MATERIAL_DIFFUSE", "MATERIAL_SPECULAR", "MATERIAL_SHININESS", "MATERIAL_REFLECTIVITY", "MATERIAL_OPACITY"]

                        # Function to check if an image has an alpha channel
                        def has_alpha_channel(image):
                            return image.depth == 32

                        # Iterate through the inputs of the node group
                        for input in node_group.inputs:
                            if input.is_linked:
                                linked_node = input.links[0].from_node
                                if linked_node.type == 'TEX_IMAGE':
                                    relative_path = linked_node.image.filepath
                                    absolute_path = bpy.path.abspath(relative_path)
                                    normalized_path = os.path.normpath(absolute_path)
                                    if os.path.isabs(normalized_path):
                                        final_path = normalized_path
                                    else:
                                        final_path = os.path.join(bpy.path.abspath("//"), normalized_path)
                                    
                                    texture_paths.append((input.name, final_path))
                                    
                                    disable_alpha = "" if has_alpha_channel(linked_node.image) else "\tDISABLE_ALPHA"
                                    
                                    if input.name == "Base Texture":
                                        file.write(f'\t\t\t\tBASE_TEXTURE "{final_path}"{disable_alpha}\n')
                                    elif input.name == "Shininess Map Texture":
                                        file.write(f'\t\t\t\tSHININESS_MAP_TEXTURE "{final_path}"{disable_alpha}\n')
                                    elif input.name == "Environment Map Texture":
                                        file.write(f'\t\t\t\tENVIRONMENT_MAP_TEXTURE "{final_path}"{disable_alpha}\n')
                            else:
                                if hasattr(input, 'default_value'):
                                    if isinstance(input.default_value, (bpy.types.bpy_prop_array, list, tuple)) and len(input.default_value) == 4:
                                        formatted_value = ' '.join(f"{v:.5f}" for v in input.default_value[:3])
                                        if input.name.upper() in always_show_attributes:
                                            file.write(f'\t\t\t\t{input.name.upper()} {formatted_value}\n')
                                    elif isinstance(input.default_value, (bpy.types.bpy_prop_array, list, tuple)) and len(input.default_value) == 3:
                                        formatted_value = ' '.join(f"{v:.5f}" for v in input.default_value)
                                        if input.name.upper() in always_show_attributes:
                                            file.write(f'\t\t\t\t{input.name.upper()} {formatted_value}\n')
                                    else:
                                        if input.name.upper() in always_show_attributes:
                                            file.write(f"\t\t\t\t{input.name} {input.default_value:.5f}\n")
                                else:
                                    if input.name.upper() in always_show_attributes:
                                        file.write(f"\t\t\t\tInput '{input.name}' has no default value attribute.\n")

                        # file.write the texture paths and their titles
                        for title, path in texture_paths:
                            disable_alpha = "" if has_alpha_channel(bpy.data.images.load(path)) else "\tDISABLE_ALPHA"
                            file.write(f'\t\t\t\t{title.upper()} "{path}"{disable_alpha}\n')
                            
                            #file.write('\t\t\t}\n')
                            #file.write('\t\t}\n')
                        
                        file.write("\t\t\t}\n")
                        # Function to rotate UVs by 180 degrees
                        def rotate_uvs_180(uv_coords):
                            return [(1.0 - uv.x, 1.0 - uv.y) for uv in uv_coords]

                        # Assuming you have the object and material selected
                        uv_layer = mesh.uv_layers.active.data if mesh.uv_layers.active else None

                        # Write the number of faces
                        file.write("\t\t\tNUM_FACES {}\n".format(len(mesh.polygons)))

                        # Iterate through the polygons and apply the UV rotation
                        for i, p in enumerate(mesh.polygons):
                            if uv_layer:
                                uv_coords = [uv_layer[loop_index].uv for loop_index in p.loop_indices]
                                rotated_uv_coords = rotate_uvs_180(uv_coords)
                                base_texture_coords = ' '.join(f'({uv[0]:.4f}, {uv[1]:.4f})' for uv in rotated_uv_coords)
                            else:
                                base_texture_coords = "(0.0, 0.0) (0.0, 0.0) (0.0, 0.0)"
                            
                            # Check for a separate UV layer for the shininess map
                            shininess_uv_layer = mesh.uv_layers.get("shininess_map")
                            if shininess_uv_layer:
                                shininess_uv_coords = [shininess_uv_layer.data[loop_index].uv for loop_index in p.loop_indices]
                                rotated_shininess_uv_coords = rotate_uvs_180(shininess_uv_coords)
                                shininess_map_coords = ' '.join(f'({uv[0]:.4f}, {uv[1]:.4f})' for uv in rotated_shininess_uv_coords)
                            else:
                                shininess_map_coords = base_texture_coords  # Fallback to base texture coordinates if no separate UV layer
                            
                            file.write(f'\t\t\tTEXTURE_FACE {i} BASE_TEXTURE {base_texture_coords} SHININESS_MAP_TEXTURE {shininess_map_coords}\n')
                        file.write("\t\t}\n")
                    else:
                        file.write("\t\tNUM_MATERIAL_REFS 0\n")
                    file.write("\t}\n")
                    file.write("}\n")

        
        return {'FINISHED'}
    
    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

def menu_func_export(self, context):
    self.layout.operator(ExportPapyrus.bl_idname, text="Papyrus ASCII Scene (.pas)")

def register():
    bpy.utils.register_class(ExportPapyrus)
    bpy.types.TOPBAR_MT_file_export.append(menu_func_export)

def unregister():
    bpy.utils.unregister_class(ExportPapyrus)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func_export)

if __name__ == "__main__":
    register()
